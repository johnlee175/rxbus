{
  "name": "Rxbus",
  "tagline": "a event bus trigger by code, constrained by thread, and avoid creating event class",
  "body": "### Project Preface\r\n>When I found I have to create a class as the distinction between events for, when I found the event bus which we are using is not based on annotations, when I found some engineers did not have a very good cognitive about the event callback in which thread, when I found that after the introduction of rxjava/rxandroid library, someone still do not know how to use and expect event bus way, I decided to do it, then the rxbus which belong to me was born.\r\n\r\n>At the beginning of the project, I use the rxjava/rxandroid library to implement the event bus model, which is presented by the master branch. but later, because of a failure to repair bug, I have to use the most simple way to achieve a robust library, to ensure its high availability, so the version of the Maven central repository can be seen in the justbus branch.\r\n\r\n>Because of the API is valuable, so the interface of these two branches can be preserved and compatible. \r\nAs for the master branch of bug, it also wants to be corrected, if you are a warm-hearted guy.\r\n\r\n### Samples\r\n>The English version of the sample will be provided in the follow-up. At present, you can also refer to the test code or the sample code in the Chinese version(see below). you know that, the code is the same!\r\n\r\n#####中文版示例 ( The Chinese Version Of The Sample )\r\n---\r\n***event bus模型介绍***\r\norg.rxbus.Rxbus类是个单例, 很容易看出来, 你只需Rxbus.singleInstance即可获得它的实例, 一般还需要经历以下步骤:\r\n- **事件接收类:** 物色一个事件接收类, 你也可以为此兴建一个类, 如果你不想自娱自乐, 这个类或其父类里应该有带@Subscribe注解的方法, 对的, 那就是当事件发生时, 你希望回调的方法;\r\n- **注册:** 将这个事件接收类的实例通过Rxbus的register开头的方法注册一下, 它将被管理起来, 一有相关事件发生将通知它, 当不再关心事件, 你会发现取消订阅也是很容易的事, 只需要将这个实例塞进Rxbus的unregister开头的方法里头;\r\n- **投递:** 当走了一套逻辑, 终于憋出来了一个事件, 那么可以使用Rxbus的post开头的方法进行事件的分发, Rxbus将会把事件通知到所有订阅者;\r\n\r\n---\r\n***示例和规则解释***  \r\n\r\n下面我们通过一个例子来说明一些规则, 那样你会更清楚怎么使用, 但这个例子我可不希望你用在实战上. 假设你有两个银行账户, 你的财务经理不知道为什么, 就是不定期的给你预先打一些差旅费, 而且忽然间银行柜员每月将等额年金打到你的PayPal账户, 偶尔你的朋友也会把钱存错在你的PayPal账户里, 你希望到账时收到一个通知, 假设你的妻子不放心你, 也想知道打款情况, 而你有些私房钱不希望她知道, 就是那个渣打银行账户. 我们通过代码来模拟这种欣欣向荣的场景:\r\n```java\r\n// 订阅方法所在的类, 即事件接收类, 不仅可以是公开类, 还可以是final类, 非公开类, 内部类\r\npublic class You {\r\n    public static final int Constant_paypal = \"paypal\".hashCode();\r\n    public static final int Constant_SCBank = \"StandardChartered\".hashCode();\r\n    public static final int Constant_Citibank = \"Citibank\".hashCode();\r\n  \r\n    // 使用code区分事件, 而不是参数类型\r\n   \r\n    @Subscribe(code = Constant_paypal, scheduler = Subscribe.SCHEDULER_CURRENT_THREAD /* 调用者当前线程中回调此方法, 如果你想同步回调 */ )\r\n    public void moneyFromPaypal(String name, int amounts) { // 方法参数个数不限, 只要投递事件时参数能对应上\r\n        System.out.println(\"friend named \" + name + \" pay $\" + amounts + \" on thread \" + Thread.currentThread().getId() + \" for \" + getClass().getSimpleName());\r\n    }\r\n\r\n    @Subscribe(code = Constant_paypal, scheduler = Subscribe.SCHEDULER_CURRENT_THREAD)\r\n    public void moneyFromPaypalQuota() { // 一个类中可以有多个方法订阅同一个事件code, 它们都将得到回调\r\n         System.out.println(\"Receive annuity $\" + amounts + \" on thread \" + Thread.currentThread().getId() + \" for \" + getClass().getSimpleName());\r\n    }\r\n\r\n    @Subscribe(code = Constant_SCBank, scheduler = Subscribe.SCHEDULER_CURRENT_THREAD)\r\n    private void moneyFromStandardCharteredBank(int amounts) { // 订阅方法可以是私有方法\r\n        System.out.println(\"StandardCharteredBank pay $\" + amounts + \" on thread \" + Thread.currentThread().getId() + \" for \" + getClass().getSimpleName());\r\n    }\r\n\r\n    @Subscribe(code = Constant_Citibank, scheduler = Subscribe.SCHEDULER_IO_POOL_THREAD /* io线程池里回调这个方法 */ )\r\n    public static void moneyFromCitibank(int amounts) { // 可以是静态方法, 当然到时需要注册的是此类类对象\r\n        System.out.println(\"Citibank pay $\" + amounts + \" on thread \" + Thread.currentThread().getId() + \" for \" + getClass().getSimpleName());\r\n    }\r\n}\r\n\r\n// 此时她将可以收到除moneyFromStandardCharteredBank以外的通知, 尽管里面没有声明方法, 但继承了啊~\r\nclass YourWife extends You {\r\n}\r\n```\r\n然后假设财务经理, 银行职员, 你的朋友长这个样子:\r\n```java\r\nclass FinanceManager {\r\n    private static final Random rand = new Random();\r\n    public static void payMoney(int amounts) {\r\n         if (rand.nextBoolean()) {\r\n            Rxbus.singleInstance.postAsync(You.Constant_Citibank, amounts);\r\n         } else {\r\n            Rxbus.singleInstance.postAsync(You.Constant_SCBank, amounts);\r\n         }\r\n    }\r\n}\r\nclass BankOfficial {\r\n    public static void payMoney() {\r\n         Rxbus.singleInstance.postSync(You.Constant_paypal, 20);\r\n    }\r\n}\r\nclass YourFriend {\r\n    private String name;\r\n    public YourFriend(String name) {\r\n         this.name = name;\r\n    }\r\n    public void payMoney(int amounts) {\r\n         Rxbus.singleInstance.postAsync(You.Constant_paypal, name, 20);\r\n    }\r\n}\r\n```\r\n需要**注意**的是:\r\n- post方法的sync和async是针对post调用来说的, 并不是说postSync是当前线程同步回调订阅者的方法, 在@Subscribe里定义的scheduler是什么, 就在那个线程调用, 回调线程仅与scheduler有关, 别犹豫;\r\n- 始终记住post方法的第一个参数是code, 而不是订阅者回调方法的第一个参数, post方法接收的是可变参数, 需要保证post方法的第二个参数开始, 要保证其顺序, 类型, 以及数量都和订阅者方法的参数列表一致, 简图如下: @Subscribe(code) method(A, B, C) -> post(code, A, B, C);\r\n- 为什么是int类型的code, 起初我想使用String, 但一个int是4个字节, 一个空字符串将近占40个字节, 果断int了, 而且这些code应该说明为常量集中管理, 使用int吧, 给每个code起个好听的名字;\r\n\r\n现在我们来测试一下:\r\n```java\r\npublic Test {\r\n    public static void main(String[] args) {\r\n        You you = new You();\r\n        YourWife wife = new YourWife();\r\n        Rxbus.singleInstance.registerSync(you); // 当用完以后, 可以使用unregisterSync取消订阅\r\n        Rxbus.singleInstance.registerSync(wife); // 测试子类回调\r\n        Rxbus.singleInstance.registerSync(You.class); // 为了接收静态方法回调\r\n        // 可以参考日志\r\n        FinanceManager.payMoney(300); // 注意在哪个线程得到的回调\r\n        BankOfficial.payMoney();\r\n        YourFriend zhangsan = new YourFriend(\"zhangsan\"), lisi = new YourFriend(\"lisi\");\r\n        zhangsan.payMoney(20000);\r\n        lisi.payMoney(5);\r\n    }\r\n}\r\n```\r\n\r\n最后需要嘚啵两句, 默认scheduler有:\r\n\r\n| 枚举值 | 描述 |\r\n|---|---|\r\n| SCHEDULER_CURRENT_THREAD | 调用者当前线程中回调 |\r\n| SCHEDULER_NEW_THREAD | 新建一个线程回调 |\r\n| SCHEDULER_IO_POOL_THREAD | IO线程池(如未使用此值, 线程池不会被创建)中回调, 一般使用无线程池大小的cache线程池 |\r\n| SCHEDULER_COMPUTE_POOL_THREAD | 计算线程池(如未使用此值, 线程池不会被创建)中回调, 一般使用固定大小的线程池(比如cpu核心数 + 1) |\r\n\r\n那么如何在自定义线程中回调呢? Android中有个主线程的概念, 以此为例, 说明一下如何绑定自定义线程:\r\n```java\r\n// 注册\r\nRxBus.singleInstance.addSchedulerWithId(SchedulerIdCenter.MAIN, AndroidSchedulers.mainThread());\r\n...\r\n// 使用\r\n@Subscribe(code=108494, scheduler= SchedulerIdCenter.MAIN)\r\nvoid yourMethod(...) {\r\n```\r\n\r\n即通过addSchedulerWithId和removeSchedulerWithId来实现自定义线程的绑定和解绑, 对于addSchedulerWithId, 它接收两个参数:\r\n* 第一个参数是一个int值, 用于@Subscribe的scheduler的枚举, 但必须保证其值大于Subscribe.SCHEDULER_FOR_FIRST_CUSTOM, 否则没效果;\r\n* 第二个参数是Scheduler类型, 你可以自己实现此接口, 也可以参考org.rxbus.ExecutorServiceScheduler和或org.rxbus.AndroidLooperScheduler;\r\n\r\n备注:\r\n目前没有单方法支持多code的计划, 即你不可能看到@Subscribe(code={1,8,9}, scheduler=...)...的情况, 取而代之, 你可以让方法接收一个参数来进一步分流, 比如触摸事件分为单击, 双击, 你既可以分配两个code, 然后对应两个不同的回调方法, 也可以分配一个code, 然后对应一个带参回调, 见下面代码:\r\n第一种:\r\n```java\r\n@Subscribe(code=SINGLE_CLICK_INT, scheduler=...)\r\nvoid method() {...}\r\n@Subscribe(code=DOUBLE_CLICK_INT, scheduler=...)\r\nvoid method() {...}\r\n```\r\n第二种:\r\n```java\r\n@Subscribe(code=CLICK_INT, scheduler=...)\r\nvoid method(int type) {\r\n    switch(type) {\r\n        case SINGLE_CLICK:\r\n        case DOUBLE_CLICK:\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Gradle\r\n```groovy\r\ncompile 'io.reactivex:rxandroid:1.2.1'\r\ncompile 'io.reactivex:rxjava:1.1.6'\r\ncompile ('com.github.johnlee175:rxbus:1.0.2') {\r\n    exclude group:'io.reactivex', module:'rxandroid'\r\n    exclude group:'io.reactivex', module:'rxjava'\r\n}\r\n```\r\n\r\n---\r\n\r\n### License\r\n```\r\nLicensed to the Apache Software Foundation (ASF) under one or more\r\ncontributor license agreements. See the NOTICE file distributed with\r\nthis work for additional information regarding copyright ownership.\r\nThe ASF licenses this file to You under the Apache license, Version 2.0\r\n(the \"License\"); you may not use this file except in compliance with\r\nthe License. You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the license for the specific language governing permissions and\r\nlimitations under the license.\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}